{"version":3,"sources":["AutoMapperBase.ts"],"names":[],"mappings":"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","file":"AutoMapperBase.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n\r\n    type stringOrClass = string | (new() => any);\r\n\r\n    /**\r\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\r\n     * .NET AutoMapper library is the pursuit of this implementation.\r\n     */\r\n    export class AutoMapperBase {\r\n        protected getMapping(mappings: { [key: string]: IMapping }, sourceKey: stringOrClass, destinationKey: stringOrClass): IMapping {\r\n            let srcKey = this.getKey(sourceKey);\r\n            let dstKey = this.getKey(destinationKey);\r\n            let mapping: IMapping = mappings[srcKey + dstKey];\r\n\r\n            if (!mapping) {\r\n                throw new Error(`Could not find map object with a source of ${srcKey} and a destination of ${dstKey}`);\r\n            }\r\n            return mapping;\r\n        }\r\n\r\n        protected getKey(keyStringOrType: string | (new () => any)): string {\r\n            if (typeof keyStringOrType === 'string') {\r\n                return keyStringOrType;\r\n            } else {\r\n                return AutoMapperHelper.getClassName(keyStringOrType);\r\n            }\r\n        }\r\n\r\n        protected isArray(sourceObject: any): boolean {\r\n            return sourceObject instanceof Array;\r\n        }\r\n\r\n        protected handleArray(mapping: IMapping, sourceArray: Array<any>, itemFunc: (sourceObject: any, destinationObject: any) => void): Array<any> {\r\n            var arrayLength = sourceArray.length;\r\n            var destinationArray = new Array<any>(sourceArray.length);\r\n\r\n            for (let index = 0; index < arrayLength; index++) {\r\n                let sourceObject = sourceArray[index];\r\n                let destinationObject: any;\r\n\r\n                if (sourceObject === null || sourceObject === undefined) {\r\n                    destinationObject = sourceObject;\r\n                } else {\r\n                    destinationObject = this.createDestinationObject(mapping.destinationTypeClass);\r\n                    itemFunc(sourceObject, destinationObject);\r\n                }\r\n\r\n                destinationArray[index] = destinationObject;\r\n            }\r\n\r\n            return destinationArray;\r\n        }\r\n\r\n        protected handleItem(mapping: IMapping, sourceObject: any, destinationObject: any, propertyFunction: (propertyName: string) => void): any {\r\n            var sourceProperties: string[] = [];\r\n            var atLeastOnePropertyMapped = false;\r\n\r\n            for (let sourcePropertyName in sourceObject) {\r\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                atLeastOnePropertyMapped = true;\r\n                sourceProperties.push(sourcePropertyName);\r\n                propertyFunction(sourcePropertyName);\r\n            }\r\n\r\n            // unsourced properties\r\n            for (let property of mapping.properties) {\r\n                if (sourceProperties.indexOf(property.name) >= 0) {\r\n                   continue;\r\n                }\r\n\r\n                atLeastOnePropertyMapped = true;\r\n                propertyFunction(property.name);\r\n            }\r\n\r\n            // return null/undefined sourceObject if no properties added\r\n            if (!atLeastOnePropertyMapped && sourceObject === null || sourceObject === undefined) {\r\n                return sourceObject;\r\n            }\r\n\r\n            return destinationObject;\r\n        }\r\n\r\n        protected handleProperty(mapping: IMapping,\r\n                                 sourceObject: any,\r\n                                 sourcePropertyName: string,\r\n                                 destinationObject: any,\r\n                                 loopMemberValuesAndFunctions: (\r\n                                                                destinations: IProperty[],\r\n                                                                conversionValuesAndFunctions: Array<any>,\r\n                                                                opts: IMemberConfigurationOptions\r\n                                                               ) => void,\r\n                                 autoMappingCallbackFunction?: (dstPropVal: any) => void): void {\r\n            var propertyMapping: IProperty = this.getMappingProperty(mapping.properties, sourcePropertyName);\r\n            if (propertyMapping) {\r\n                this.handlePropertyWithPropertyMapping(mapping, propertyMapping, sourceObject, sourcePropertyName, loopMemberValuesAndFunctions);\r\n            } else {\r\n                this.handlePropertyWithAutoMapping(mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction);\r\n            }\r\n        }\r\n\r\n        protected setPropertyValue(mapping: IMapping, destinationObject: any, destinationProperty: IProperty, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    this.handleNestedForAllMemberMappings(destinationObject, destinationProperty, destinationPropertyValue, forAllMemberMapping);\r\n                }\r\n            } else {\r\n                this.setNestedPropertyValue(destinationObject, destinationProperty, destinationPropertyValue);\r\n            }\r\n        }\r\n\r\n        protected setPropertyValueByName(mapping: IMapping, destinationObject: any, destinationProperty: string, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    forAllMemberMapping(destinationObject, destinationProperty, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationProperty] = destinationPropertyValue;\r\n            }\r\n        }\r\n        protected createDestinationObject(destinationType: new () => any): any {\r\n            // create empty destination object.\r\n            return destinationType\r\n                ? new destinationType()\r\n                : {};\r\n        }\r\n\r\n       private handleNestedForAllMemberMappings(destinationObject: any,\r\n                                                 destinationProperty: IProperty,\r\n                                                 destinationPropertyValue: any,\r\n                                                 forAllMemberMapping: (destinationObject: any, destinationPropertyName: string, value: any) => void): void {\r\n            if (destinationProperty.children && destinationProperty.children.length > 0) {\r\n                this.setChildPropertyValues(destinationObject, destinationProperty, destinationPropertyValue);\r\n            } else {\r\n                forAllMemberMapping(destinationObject, destinationProperty.name, destinationPropertyValue);\r\n            }\r\n        }\r\n\r\n        private setNestedPropertyValue(destinationObject: any, destinationProperty: IProperty, destinationPropertyValue: any): void {\r\n            if (destinationProperty.children && destinationProperty.children.length > 0) {\r\n                this.setChildPropertyValues(destinationObject, destinationProperty, destinationPropertyValue);\r\n            } else {\r\n                destinationObject[destinationProperty.name] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        private setChildPropertyValues(destinationObject: any, destinationProperty: IProperty, destinationPropertyValue: any): void {\r\n            var dstObj: any;\r\n            if (destinationObject.hasOwnProperty(destinationProperty.name) && destinationObject[destinationProperty.name]) {\r\n                dstObj = destinationObject[destinationProperty.name];\r\n            } else {\r\n                destinationObject[destinationProperty.name] = dstObj = {};\r\n            }\r\n\r\n            for (var index = 0, count = destinationProperty.children.length; index < count; index++) {\r\n                this.setNestedPropertyValue(dstObj, destinationProperty.children[index], destinationPropertyValue);\r\n            }\r\n        }\r\n\r\n        private getMappingProperty(properties: IProperty[], sourcePropertyName: string): IProperty {\r\n            for (let property of properties) {\r\n                if (property.name === sourcePropertyName) {\r\n                    return property;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private handlePropertyWithAutoMapping(mapping: IMapping,\r\n                                              sourceObject: any,\r\n                                              sourcePropertyName: string,\r\n                                              destinationObject: any,\r\n                                              autoMappingCallbackFunction?: (dstPropVal: any) => void): void {\r\n            // no forMember mapping exists, auto map properties, except for the situation where ignoreAllNonExisting is specified.\r\n            if (mapping.ignoreAllNonExisting) {\r\n                return;\r\n            }\r\n\r\n            // use profile mapping when specified; otherwise, specify source property name as destination property name.\r\n            let destinationPropertyName = this.getDestinationPropertyName(mapping.profile, sourcePropertyName);\r\n            var destinationPropertyValue = sourceObject ? sourceObject[sourcePropertyName] : null;\r\n            this.setPropertyValueByName(mapping, destinationObject, destinationPropertyName, destinationPropertyValue);\r\n            if (autoMappingCallbackFunction) {\r\n                autoMappingCallbackFunction(destinationPropertyValue);\r\n            }\r\n        }\r\n\r\n        private handlePropertyWithPropertyMapping(\r\n            mapping: IMapping,\r\n            propertyMapping: IProperty,\r\n            sourceObject: any,\r\n            sourcePropertyName: string,\r\n            loopMemberValuesAndFunctions: (destinations: IProperty[], conversionValuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions) => void): void {\r\n                // a forMember mapping exists\r\n\r\n                var {\r\n                    ignore,\r\n                    conditionFunction,\r\n                    children,\r\n                    destinations,\r\n                    conversionValuesAndFunctions\r\n                } = propertyMapping;\r\n\r\n                if (children) {\r\n                    var childSourceObject = sourceObject[propertyMapping.name];\r\n                    for (let index = 0; index < children.length; index++) {\r\n                        let child = children[index];\r\n                        this.handlePropertyWithPropertyMapping(mapping, child, childSourceObject, child.name, loopMemberValuesAndFunctions);\r\n                    }\r\n                }\r\n\r\n                // ignore ignored properties\r\n                if (ignore) {\r\n                    return;\r\n                }\r\n\r\n                // check for condition function\r\n                if (conditionFunction) {\r\n                    // and, if there, return when the condition is not met.\r\n                    if (conditionFunction(sourceObject) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // it makes no sense to handle a property without destination(s).\r\n                if (!destinations) {\r\n                    return;\r\n                }\r\n\r\n                var memberConfigurationOptions: IMemberConfigurationOptions = {\r\n                    mapFrom: (): void => {//sourceMemberKey: string) {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    condition: (predicate: ((sourceObject: any) => boolean)): void => {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    sourceObject: sourceObject,\r\n                    sourcePropertyName: sourcePropertyName,\r\n                    intermediatePropertyValue: sourceObject ? sourceObject[sourcePropertyName] : sourceObject\r\n                };\r\n\r\n                loopMemberValuesAndFunctions(destinations, conversionValuesAndFunctions, memberConfigurationOptions);\r\n        }\r\n\r\n        private getDestinationPropertyName(profile: IProfile, sourcePropertyName: string): string {\r\n            if (!profile) {\r\n                return sourcePropertyName;\r\n            }\r\n\r\n            // TODO BL no support yet for INamingConvention.splittingCharacter\r\n\r\n            try {\r\n                // First, split the source property name based on the splitting expression.\r\n                // TODO BL Caching of RegExp splitting!\r\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\r\n\r\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\r\n                for (let index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\r\n                    if (sourcePropertyNameParts[index] === '') {\r\n                        sourcePropertyNameParts.splice(index, 1);\r\n                    }\r\n                }\r\n\r\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\r\n            } catch (error) {\r\n                return sourcePropertyName;\r\n            }\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}