{"version":3,"sources":["AutoMapper.ts"],"names":[],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapperBase.ts\" />\r\n/// <reference path=\"AsyncAutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    // interface shorthands\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n    type IDMCO = IMemberConfigurationOptions;\r\n    type ISMCO = ISourceMemberConfigurationOptions;\r\n    type IMC = IMemberCallback;\r\n    type IRC = IResolutionContext;\r\n    type TC = TypeConverter;\r\n\r\n    // method overload shorthands\r\n    type stringOrClass = string | (new() => any);\r\n    type forMemberValueOrFunction = any | ((opts: IDMCO) => any) | ((opts: IDMCO, cb: IMC) => void);\r\n    type convertUsingClassOrInstanceOrFunction = ((ctx: IRC) => any) | ((ctx: IRC, callback: IMapCallback) => void) | TC | (new() => TC);\r\n\r\n    export class AutoMapper extends AutoMapperBase {\r\n        private static _instance = new AutoMapper();\r\n\r\n        private _profiles: { [name: string]: IProfile };\r\n        private _mappings: { [key: string]: IMapping };\r\n\r\n        private _asyncMapper: AsyncAutoMapper;\r\n\r\n        public static getInstance(): AutoMapper {\r\n            return AutoMapper._instance;\r\n        }\r\n\r\n        /**\r\n         * This class is intended to be a Singleton. Preferrably use getInstance() \r\n         * function instead of using the constructor directly from code.\r\n         */\r\n        constructor() {\r\n            super();\r\n\r\n            if (AutoMapper._instance) {\r\n                return AutoMapper._instance;\r\n            } else {\r\n                AutoMapper._instance = this;\r\n\r\n                this._profiles = {};\r\n                this._mappings = {};\r\n\r\n                this._asyncMapper = new AsyncAutoMapper();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Initializes the mapper with the supplied configuration.\r\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\r\n         */\r\n        public initialize(configFunction: (config: IConfiguration) => void): void {\r\n            var that = this;\r\n\r\n            var configuration: IConfiguration = <any>{\r\n                addProfile: (profile: IProfile) : void => {\r\n                    profile.configure();\r\n                    that._profiles[profile.profileName] = profile;\r\n                },\r\n                createMap: function (sourceKey: string, destinationKey: string): IFluentFunc {\r\n                    // pass through using arguments to keep createMap's currying support fully functional.\r\n                    return that.createMap.apply(that, arguments);\r\n                }\r\n            };\r\n\r\n            configFunction(configuration);\r\n        }\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.ICreateMapFluentFunctions}\r\n         */\r\n        public createMap(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any)): IFluentFunc {\r\n            // provide currying support.\r\n            if (arguments.length < 2) {\r\n                return AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\r\n\r\n            return this.createMapGetFluentApiFunctions(mapping);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKeyOrType: stringOrClass, destinationKeyOrType: stringOrClass, sourceObject: any): any {\r\n            if (arguments.length === 3) {\r\n                return this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                return (srcObj: any) => this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new() => any), srcObj: any) => this.map(sourceKeyOrType, dstKey, srcObj);\r\n            }\r\n\r\n            return (srcKey: string | (new() => any), dstKey: string | (new() => any), srcObj: any) => this.map(srcKey, dstKey, srcObj);\r\n        }\r\n\r\n        /**\r\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\r\n         */\r\n        public mapAsync(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any), sourceObject: any, callback: IMapCallback): any {\r\n            switch (arguments.length) {\r\n                case 4:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject, callback);\r\n                case 3:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject);\r\n                case 2:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType);\r\n                case 1:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType);\r\n                default:\r\n                    throw new Error('The mapAsync function expects between 1 and 4 parameters, you provided ' + arguments.length + '.');\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\r\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\r\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable. \r\n         */\r\n        public assertConfigurationIsValid(strictMode: boolean = true): void {\r\n            AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\r\n        }\r\n\r\n        private createMapForMember(parameters: ICreateMapParameters): IFluentFunc {\r\n            var { mapping, destinationProperty, conversionValueOrFunction, sourceMapping, fluentFunctions } = parameters;\r\n\r\n            var metadata = AutoMapperHelper.getMappingMetadataFromConfigFunction(destinationProperty, conversionValueOrFunction, sourceMapping);\r\n\r\n            var property: IProperty;\r\n            if (!sourceMapping) {\r\n                property = this.getPropertyByDestinationProperty(mapping.properties, destinationProperty);\r\n                if (!property) {\r\n                    property = this.getOrCreateProperty({\r\n                        propertyNameParts: metadata.source.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: mapping.properties,\r\n                        parent: null,\r\n                        destination: destinationProperty,\r\n                        sourceMapping: sourceMapping\r\n                    });\r\n                }\r\n            } else {\r\n                property = this.getOrCreateProperty({\r\n                    propertyNameParts: metadata.source.split('.'),\r\n                    mapping: mapping,\r\n                    propertyArray: mapping.properties,\r\n                    parent: null,\r\n                    destination: destinationProperty,\r\n                    sourceMapping: sourceMapping\r\n                });\r\n            }\r\n\r\n            if (metadata.async) {\r\n                this.createMapForMemberAsync(property, conversionValueOrFunction, metadata);\r\n            } else {\r\n                this.createMapForMemberSync(property, conversionValueOrFunction, metadata);\r\n            }\r\n\r\n            return fluentFunctions;\r\n        }\r\n\r\n        private createMapForMemberAsync(property: IProperty, valueOrFunction: any, metadata: IMemberMappingMetaData): void {\r\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\r\n                return;\r\n            }\r\n\r\n            this._asyncMapper.createMapForMember(property, <(opts: IDMCO, cb: IMemberCallback) => void>valueOrFunction, metadata);\r\n        }\r\n\r\n        private createMapForMemberSync(property: IProperty, valueOrFunction: any, metadata: IMemberMappingMetaData): void {\r\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\r\n                return;\r\n            }\r\n\r\n            this.createMapForMemberHandleMapFrom(property, metadata);\r\n            property.conditionFunction = metadata.condition;\r\n            property.conversionValuesAndFunctions.push(valueOrFunction);\r\n        }\r\n\r\n        private createMapForMemberHandleMapFrom(property: IProperty, metadata: IMemberMappingMetaData): void {\r\n            if (metadata.source === metadata.destination) {\r\n                return;\r\n            }\r\n\r\n            var { mapping, root } = property.metadata;\r\n\r\n            var sourceNameParts = metadata.source.split('.');\r\n            if (sourceNameParts.length === property.level) {\r\n                this.updatePropertyName(sourceNameParts, property);\r\n            } else {\r\n                // check if only one destination on property root. in that case, rebase property and overwrite root.\r\n                if (root.metadata.destinationCount === 1) {\r\n                    var propertyRootIndex = mapping.properties.indexOf(root);\r\n                    mapping.properties[propertyRootIndex] = undefined;\r\n                    var propArray: IProperty[] = [];\r\n                    var newProperty = this.getOrCreateProperty({\r\n                        propertyNameParts: metadata.source.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: propArray,\r\n                        parent: null,\r\n                        destination: metadata.destination,\r\n                        sourceMapping: metadata.sourceMapping\r\n                    });\r\n                    newProperty.conditionFunction = property.conditionFunction;\r\n                    newProperty.conversionValuesAndFunctions = property.conversionValuesAndFunctions;\r\n                    mapping.properties[propertyRootIndex] = propArray[0];\r\n                } else {\r\n                    throw new Error('Rebasing properties with multiple destinations is not yet implemented.');\r\n                }\r\n            }\r\n        }\r\n\r\n        private updatePropertyName(sourceNameParts: string[], property: IProperty): void {\r\n            property.name = sourceNameParts[sourceNameParts.length - 1];\r\n            if (sourceNameParts.length === 1) {\r\n                return;\r\n            }\r\n\r\n            this.updatePropertyName(sourceNameParts.splice(0, 1), property.metadata.parent);\r\n        }\r\n\r\n        private createMapForMemberHandleIgnore(property: IProperty, metadata: IMemberMappingMetaData): boolean {\r\n            if (property.ignore || metadata.ignore) {\r\n                // source name will always be destination name when ignoring.\r\n                property.name = metadata.destination;\r\n                property.ignore = true;\r\n                property.async = false;\r\n                property.destinations = null;\r\n                property.conversionValuesAndFunctions = [];\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private getPropertyByDestinationProperty(properties: IProperty[], destinationPropertyName: string): IProperty {\r\n            if (properties === null || properties === undefined) {\r\n                return null;\r\n            }\r\n\r\n            for (let srcProp of properties) {\r\n                if (srcProp.metadata.destinations !== null && srcProp.metadata.destinations !== undefined) {\r\n                    for (let destination in srcProp.metadata.destinations) {\r\n                        if (destination === destinationPropertyName) {\r\n                            return srcProp.metadata.destinations[destination].source;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let childProp = this.getPropertyByDestinationProperty(srcProp.children, destinationPropertyName);\r\n                if (childProp != null) {\r\n                    return childProp;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private getOrCreateProperty(parameters: IGetOrCreatePropertyParameters): IProperty {\r\n            var { propertyNameParts, mapping, parent, propertyArray, destination, sourceMapping } = parameters;\r\n\r\n            var name = propertyNameParts[0];\r\n\r\n            var property: IProperty;\r\n            if (propertyArray) {\r\n                for (var child of propertyArray) {\r\n                    if (child.name === name) {\r\n                        property = child;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (property === undefined || property === null) {\r\n                property = this.createProperty({\r\n                    name: name,\r\n                    parent: parent,\r\n                    propertyArray: propertyArray,\r\n                    sourceMapping: sourceMapping,\r\n                    mapping: mapping\r\n                });\r\n            }\r\n\r\n            if (propertyNameParts.length === 1) {\r\n                if (destination) {\r\n                    let destinationTargetArray: IProperty[] = property.destinations ? property.destinations : [];\r\n                    var dstProp = this.getOrCreateProperty({\r\n                        propertyNameParts: destination.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: destinationTargetArray,\r\n                        parent: null,\r\n                        destination: null,\r\n                        sourceMapping: sourceMapping\r\n                    });\r\n                    if (destinationTargetArray.length > 0) {\r\n                        property.metadata.root.metadata.destinations[destination] = { source: property, destination: dstProp };\r\n                        property.metadata.root.metadata.destinationCount++;\r\n                        property.destinations = destinationTargetArray;\r\n                    }\r\n                }\r\n                return property;\r\n            }\r\n\r\n            if (property.children === null || property.children === undefined) {\r\n               property.children = [];\r\n            }\r\n\r\n            return this.getOrCreateProperty({\r\n                propertyNameParts: propertyNameParts.slice(1),\r\n                mapping: mapping,\r\n                propertyArray: property.children,\r\n                parent: property,\r\n                destination: destination,\r\n                sourceMapping: sourceMapping\r\n            });\r\n        }\r\n\r\n        private createProperty(parameters: ICreatePropertyParameters): IProperty {\r\n            var { name, parent, propertyArray, sourceMapping, mapping } = parameters;\r\n\r\n            var property: IProperty = {\r\n                name: name,\r\n                metadata: {\r\n                    mapping: mapping,\r\n                    root: parent ? parent.metadata.root : null,\r\n                    parent: parent,\r\n                    destinations: {},\r\n                    destinationCount: 0\r\n                },\r\n                sourceMapping: sourceMapping,\r\n                level: !parent ? 1 : parent.level + 1,\r\n                ignore: false,\r\n                async: false,\r\n                conversionValuesAndFunctions: []\r\n            };\r\n\r\n            if (property.metadata.root === null) {\r\n                property.metadata.root = property;\r\n            }\r\n\r\n            if (propertyArray) {\r\n                propertyArray.push(property);\r\n            }\r\n\r\n            return property;\r\n        }\r\n\r\n        private createMapForSourceMember(mapping: IMapping, fluentFunc: IFluentFunc, srcProp: string, cnf: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)): IFluentFunc {\r\n            if (typeof cnf !== 'function') {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\r\n            }\r\n\r\n            return this.createMapForMember({\r\n                mapping: mapping,\r\n                fluentFunctions: fluentFunc,\r\n                destinationProperty: srcProp,\r\n                conversionValueOrFunction: cnf,\r\n                sourceMapping: true\r\n            });\r\n        }\r\n\r\n        private createMapForAllMembers(mapping: IMapping, fluentFunc: IFluentFunc, func: (dstObj: any, dstProp: string, val: any) => void): IFluentFunc {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapIgnoreAllNonExisting(mapping: IMapping, fluentFunc: IFluentFunc): IFluentFunc {\r\n            mapping.ignoreAllNonExisting = true;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertToType(mapping: IMapping, fluentFunc: IFluentFunc, typeClass: new () => any): IFluentFunc {\r\n            if (mapping.destinationTypeClass) {\r\n                throw new Error('Destination type class can only be set once.');\r\n            }\r\n\r\n            mapping.destinationTypeClass = typeClass;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertUsing(mapping: IMapping, tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void {\r\n            try {\r\n                // check if sync: TypeConverter instance\r\n                if (tcClassOrFunc instanceof TypeConverter) {\r\n                    this.configureSynchronousConverterFunction(mapping, tcClassOrFunc.convert);\r\n                    return;\r\n                }\r\n\r\n                var functionParameters = AutoMapperHelper.getFunctionParameters(<any>tcClassOrFunc);\r\n                switch (functionParameters.length) {\r\n                    case 0:\r\n                        // check if sync: TypeConverter class definition\r\n                        var typeConverter: TypeConverter;\r\n                        try {\r\n                            typeConverter = (<TypeConverter>new (<new() => TypeConverter>tcClassOrFunc)());\r\n                        } catch (e) {\r\n                            // Obviously, typeConverterClassOrFunction is not a TypeConverter class definition\r\n                        }\r\n                        if (typeConverter instanceof TypeConverter) {\r\n                            this.configureSynchronousConverterFunction(mapping, typeConverter.convert);\r\n                            return;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        // sync: function with resolutionContext parameter\r\n                        this.configureSynchronousConverterFunction(mapping, <(resolutionContext: IResolutionContext) => any>tcClassOrFunc);\r\n                        return;\r\n                    case 2:\r\n                        // check if async: function with resolutionContext and callback parameters\r\n                        this._asyncMapper.createMapConvertUsing(mapping, <(ctx: IResolutionContext, cb: IMapCallback) => void>tcClassOrFunc);\r\n                        return;\r\n                }\r\n\r\n                // okay, just try feeding the function to the configure function anyway...\r\n                this.configureSynchronousConverterFunction(mapping, <any>tcClassOrFunc);\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. ${e}`);\r\n            }\r\n\r\n            throw new Error(`The value provided for typeConverterClassOrFunction is invalid.`);\r\n        }\r\n\r\n        private configureSynchronousConverterFunction(mapping: IMapping, converterFunc: Function): void {\r\n            if (!converterFunc || AutoMapperHelper.getFunctionParameters(converterFunc).length !== 1) {\r\n                throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\r\n            }\r\n\r\n            mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>converterFunc;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any): any => this.mapItemUsingTypeConverter(m, srcObj, dstObj);\r\n        }\r\n\r\n\r\n        private createMapWithProfile(mapping: IMapping, profileName: string): void {\r\n            // check if given profile exists\r\n            var profile = this._profiles[profileName];\r\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\r\n                throw new Error(`Could not find profile with profile name '${profileName}'.`);\r\n            }\r\n\r\n            mapping.profile = profile;\r\n            // merge mappings\r\n            this.createMapWithProfileMergeMappings(mapping, profileName);\r\n        }\r\n\r\n        private createMapWithProfileMergeMappings(mapping: IMapping, profileName: string): void {\r\n            var profileMappingKey = `${profileName}=>${mapping.sourceKey}${profileName}=>${mapping.destinationKey}`;\r\n            var profileMapping: IMapping = this._mappings[profileMappingKey];\r\n            if (!profileMapping) {\r\n                return;\r\n            }\r\n\r\n            // append forAllMemberMappings calls to the original array.\r\n            if (profileMapping.forAllMemberMappings.length > 0) {\r\n                mapping.forAllMemberMappings.push(...profileMapping.forAllMemberMappings);\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.typeConverterFunction) {\r\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.destinationTypeClass) {\r\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\r\n            }\r\n\r\n            // walk through all the profile's property mappings\r\n            for (let property of profileMapping.properties) {\r\n                this.mergeProperty(mapping, mapping.properties, property);\r\n            }\r\n        }\r\n\r\n        private mergeProperty(mapping: IMapping, properties: IProperty[], property: IProperty): void {\r\n            var overwritten = false;\r\n            for (let index = 0; index < mapping.properties.length; index++) {\r\n                let existing = mapping.properties[index];\r\n\r\n                if (existing.name === property.name) {\r\n                    // in which case, we overwrite that one with the profile's property mapping.\r\n                    // okay, maybe a bit rude, but real merging is pretty complex and you should\r\n                    // probably not want to combine normal and profile createMap.forMember calls.\r\n                    mapping.properties[index] = property;\r\n                    overwritten = true;\r\n                }\r\n            }\r\n\r\n            if (overwritten === false) {\r\n                mapping.properties.push(property);\r\n            }\r\n        }\r\n\r\n        private mapInternal(mapping: IMapping, sourceObject: any): any {\r\n            if (mapping.async) {\r\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\r\n            }\r\n\r\n            if (super.isArray(sourceObject)) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass));\r\n        }\r\n\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject);\r\n            });\r\n            return destinationArray;\r\n        }\r\n\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any): void {\r\n            destinationObject = super.handleItem(mapping, sourceObject, destinationObject, (propertyName: string) => {\r\n                this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\r\n            });\r\n            return destinationObject;\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, arrayIndex?: number): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            return (<(ctx: IResolutionContext) => any>mapping.typeConverterFunction)(resolutionContext);\r\n        }\r\n\r\n        private mapProperty(mapping: IMapping, sourceObject: any, destinationObject: any, sourceProperty: string): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject,\r\n                (destinations: IProperty[], valuesAndFunctions: Array<any>, opts: IDMCO) => {\r\n                    var destinationPropertyValue = this.handlePropertyMappings(valuesAndFunctions, opts);\r\n                    for (let destination of destinations) {\r\n                        super.setPropertyValue(mapping, destinationObject, destination, destinationPropertyValue);\r\n                    }\r\n                });\r\n        }\r\n\r\n        private handlePropertyMappings(valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions): any {\r\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\r\n                return opts.intermediatePropertyValue;\r\n            }\r\n\r\n            var valueOrFunction = valuesAndFunctions[0];\r\n            if (typeof valueOrFunction === 'function') {\r\n                var result = valueOrFunction(opts);\r\n\r\n                if (typeof result !== 'undefined') {\r\n                    opts.intermediatePropertyValue = result;\r\n                }\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            } else {\r\n                // valueOrFunction is a value\r\n                opts.intermediatePropertyValue = valueOrFunction;\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            }\r\n        }\r\n\r\n        private createMappingObjectForGivenKeys(srcKeyOrType: string | (new() => any), dstKeyOrType: string | (new() => any)): IMapping {\r\n            var mapping: IMapping = {\r\n                sourceKey: super.getKey(srcKeyOrType),\r\n                destinationKey: super.getKey(dstKeyOrType),\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                properties: [],\r\n                typeConverterFunction: undefined,\r\n                mapItemFunction: (m: IMapping, srcObj: any, dstObj: any): any => this.mapItem(m, srcObj, dstObj),\r\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\r\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\r\n                profile: undefined,\r\n                async: false\r\n            };\r\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\r\n            return mapping;\r\n        }\r\n\r\n        private createMapGetFluentApiFunctions(mapping: IMapping): IFluentFunc {\r\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentFunc: IFluentFunc = {\r\n                forMember: (prop: string, valFunc: forMemberValueOrFunction) : IFluentFunc =>\r\n                    this.createMapForMember({\r\n                        mapping: mapping,\r\n                        fluentFunctions: fluentFunc,\r\n                        destinationProperty: prop,\r\n                        conversionValueOrFunction: valFunc,\r\n                        sourceMapping: false\r\n                    }),\r\n                forSourceMember: (prop: string, cfgFunc: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)) : IFluentFunc =>\r\n                    this.createMapForSourceMember(mapping, fluentFunc, prop, cfgFunc),\r\n                forAllMembers: (func: (dstObj: any, dstProp: string, value: any) => void) : IFluentFunc =>\r\n                    this.createMapForAllMembers(mapping, fluentFunc, func),\r\n                ignoreAllNonExisting: () : IFluentFunc => this.createMapIgnoreAllNonExisting(mapping, fluentFunc),\r\n                convertToType: (type: new () => any) : IFluentFunc => this.createMapConvertToType(mapping, fluentFunc, type),\r\n                convertUsing: (tcClassOrFunc: convertUsingClassOrInstanceOrFunction) : void =>\r\n                    this.createMapConvertUsing(mapping, tcClassOrFunc),\r\n                withProfile: (profile: string) : void => this.createMapWithProfile(mapping, profile)\r\n            };\r\n\r\n            return fluentFunc;\r\n        }\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.AutoMapper = ((app: any) => {\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);\r\n"],"sourceRoot":"/source/"}