{"version":3,"sources":["AsyncAutoMapper.ts"],"names":[],"mappings":"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","file":"AsyncAutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    /**\r\n     * AsyncAutoMapper implementation, for asynchronous mapping support when using AutoMapper.\r\n     */\r\n    export class AsyncAutoMapper extends AutoMapperBase {\r\n        private static asyncInstance = new AsyncAutoMapper();\r\n\r\n        constructor() {\r\n            super();\r\n            AsyncAutoMapper.asyncInstance = this;\r\n        }\r\n\r\n        public createMapForMember(property: IProperty,\r\n                                  func: ((opts: IMemberConfigurationOptions, cb: IMemberCallback) => void),\r\n                                  metadata: IMemberMappingMetaData): void {\r\n            var { mapping } = property.metadata;\r\n\r\n            mapping.async = true;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any, cb: IMapCallback) => this.mapItem(m, srcObj, dstObj, cb);\r\n            property.async = true;\r\n            property.conversionValuesAndFunctions.push(func);\r\n        }\r\n\r\n        public createMapConvertUsing(mapping: IMapping, converterFunction: (ctx: IResolutionContext, cb: IMapCallback) => void): void {\r\n            mapping.async = true;\r\n            mapping.typeConverterFunction = converterFunction;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any, cb: IMapCallback) => this.mapItemUsingTypeConverter(m, srcObj, dstObj, cb);\r\n        }\r\n\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any)): (dstKey: string | (new () => any), srcObj: any, cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey: string | (new () => any)): (srcObj: any, cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey?: string | (new () => any), sourceObject?: any): (cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey?: string | (new () => any), sourceObject?: any, cb?: IMapCallback): void;\r\n        public map(\r\n            mappings: { [key: string]: IMapping }, sourceKey: string | (new () => any), destinationKey?: string | (new () => any), sourceObject?: any, callback?: IMapCallback\r\n        ): any /* actually, void (impossible with overloads) */ {\r\n\r\n            switch (arguments.length) {\r\n                case 5:\r\n                    this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), sourceObject, callback);\r\n                    return;\r\n                // provide performance optimized (preloading) currying support.\r\n                case 4:\r\n                    return (cb: IMapCallback) => this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), sourceObject, cb);\r\n                case 3:\r\n                    return (srcObj: any, cb: IMapCallback) => this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), srcObj, cb);\r\n                case 2:\r\n                    return (dstKey: string | (new () => any), srcObj: any, cb: IMapCallback) => this.map(mappings, sourceKey, dstKey, srcObj, cb);\r\n                default:\r\n                    throw new Error('The AsyncAutoMapper.map function expects between 2 and 5 parameters, you provided ' + arguments.length + '.');\r\n            }\r\n        }\r\n\r\n        public mapWithMapping(mapping: IMapping, sourceObject: any, callback: IMapCallback): void {\r\n            if (super.isArray(sourceObject)) {\r\n                this.mapArray(mapping, sourceObject, callback);\r\n                return;\r\n            }\r\n\r\n            return (<IAsyncMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass), callback);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceArray The source array to map.\r\n         * @returns {Array<any>} Destination array.\r\n         */\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>, callback: IMapCallback): void {\r\n            var callbacksToGo = 0;\r\n\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                callbacksToGo++;\r\n                (<IAsyncMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject, (result: any): void => {\r\n                    callbacksToGo--;\r\n                });\r\n            });\r\n\r\n            var waitForCallbackToSend = (): void => {\r\n                if (callbacksToGo === 0) {\r\n                    callback(destinationArray);\r\n                } else {\r\n                    setTimeout((): void => {\r\n                        waitForCallbackToSend();\r\n                    }, 10 * callbacksToGo);\r\n                }\r\n            };\r\n\r\n            waitForCallbackToSend();\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, callback: IMapCallback): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            (<(ctx: IResolutionContext, cb: IMapCallback) => any>mapping.typeConverterFunction)(resolutionContext, callback);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param callback The callback to call after async mapping has been executed.\r\n         */\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any, callback: IMapCallback): void {\r\n            var callbacksToGo = 0;\r\n\r\n            super.handleItem(mapping, sourceObject, destinationObject, (sourceProperty: string) => {\r\n                callbacksToGo++;\r\n                this.mapProperty(mapping, sourceObject, sourceProperty, destinationObject, (result: any): void => {\r\n                    callbacksToGo--;\r\n                });\r\n            });\r\n\r\n            var waitForCallbackToSend = (): void => {\r\n                if (callbacksToGo === 0) {\r\n                    callback(destinationObject);\r\n                } else {\r\n                    setTimeout((): void => {\r\n                        waitForCallbackToSend();\r\n                    }, 10 * callbacksToGo);\r\n                }\r\n            };\r\n\r\n            waitForCallbackToSend();\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param sourcePropertyName The source property to map.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param callback The callback to call after async property mapping has been executed.\r\n         */\r\n        private mapProperty(mapping: IMapping, sourceObject: any, sourceProperty: string, destinationObject: any, callback: IMemberCallback): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject,\r\n                (destinations: IProperty[], valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions) => {\r\n                    this.handlePropertyMappings(valuesAndFunctions, opts, (destinationPropertyValue: any) => {\r\n                        for (let destination of destinations) {\r\n                            super.setPropertyValue(mapping, destinationObject, destination, destinationPropertyValue);\r\n                        }\r\n                        callback(destinationPropertyValue);\r\n                    });\r\n                }, (destinationPropertyValue: any) => {\r\n                    callback(destinationPropertyValue);\r\n                });\r\n        }\r\n\r\n        private handlePropertyMappings(valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions, callback: IMemberCallback): void {\r\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\r\n                callback(opts.intermediatePropertyValue);\r\n                return;\r\n            }\r\n\r\n            var valueOrFunction = valuesAndFunctions[0];\r\n\r\n            if (typeof valueOrFunction === 'function') {\r\n                this.handlePropertyMappingFunction(valueOrFunction, opts, (result: any) => {\r\n                    if (typeof result !== 'undefined') {\r\n                        opts.intermediatePropertyValue = result;\r\n\r\n                        // recursively walk values/functions\r\n                        this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\r\n                    }\r\n                });\r\n            } else {\r\n                // valueOrFunction is a value\r\n                opts.intermediatePropertyValue = valueOrFunction;\r\n\r\n                // recursively walk values/functions\r\n                this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\r\n            }\r\n        }\r\n\r\n        private handlePropertyMappingFunction(func: Function, opts: IMemberConfigurationOptions, callback: IMemberCallback): void {\r\n            // check if function is asynchronous\r\n            var args = AutoMapperHelper.getFunctionParameters(func);\r\n            if (args.length === 2) { // asynchronous: opts, callback\r\n                func(opts, callback);\r\n                return;\r\n            }\r\n\r\n            callback(func(opts));\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}